# sort-code
riven's sort code

哈希
1.哈希函数：
希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系f找到给定值K的像f(K)，不需要比较便可直接取得所查记录。
	* 
直接定址法：取关键字或关键字的某个线性函数值为哈希地址
	* 
除留余数法：取关键字被某个不大于哈希表长m的数p除后所得的余数为哈希地址
	* 
数字分析法：取关键字的若干位数字组成哈希地址
	* 
折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址。适用于关键字位数很多，并且关键字中每一位上数字分布大致均匀
	* 
平方取中法：取关键字平方后的中间几位为哈希地址，是一种较为常用的构造哈希函数的方法。
	* 
随机函数法：选择一个随机数，取关键字的随机函数值作为哈希地址


采用不同哈希函数的考虑因素有：
	* 
计算哈希函数需要的时间
	* 
关键字的长度
	* 
哈希表的大小
	* 
关键字的分布情况
	* 
记录的查找频率


2.冲突处理方法：
开放定址法：增量序列di 
	* 
线性探测法：di=1,2,3,....m-1 线性探测再散列
	* 
二次探测法：di =1^2, -1^2, 2^2, -2^2, (+-)k^2 二次探测再散列
	* 
随机探测法：di =伪随机数列 伪随机探测再散列


链地址法：将所有关键字为同义词的记录存储在同一线性链表中。
再哈希法：RH是不同的哈希函数，即同义词产生地址冲突的时候，计算另一个哈希函数地址，直到冲突不再发生。不容易聚集但增加了计算时间。

排序
将一个数据元素（或记录）的任意序列，重新排列成个按关键字有序的序列。
因为有序表可以采用可以采用查找效率较高的折半查找法，平均查找长度为，而无序的顺序表只能按照顺序查找，平均查找长度为（n+1)/2。又如建造树表（无论是二叉排序树或者B-树）的过程本身就是一个排序的过程。
排序算法稳不稳定：关键字Ki = Kj, 如果在排序前Ri领先Rj，排序后仍这样就稳定。反过来就不稳定。
涉及的存储器不同，将排序方法分为两大类：
	* 
内部排序：待排记录存放在存放在计算机随机存储器中进行的排序过程。
	* 
外部排序：待排记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中需要对外存进行访问的排序过程。



待排记录的存储方式：
	* 
存放在地址连续的一组存储单元上，则实现排序必须借助移动记录
	* 
存放在静态链表中，记录之间的次序关系由指针指示，实现排序不需要移动记录，仅修改指针就可以
	* 
存放在地址连续的存储单元，同时另设一个指示各个记录存储位置的地址向量，排序过程中不移动记录本身，而移动地址向量中这些记录的地址，在排序结束后再按照地址向量中的值调整记录的存储位置


1.直接插入排序 straight insert sort
是一种最简单的排序方法，基本操作时将一个录插入到已排好的有序表中，从而得到一个新的、记录数增1的有序表

折半查找
    for(int j = 1; j < 10; ++j){
        int tmp = a[j];
        int high = j - 1;
        int low = 0;
        while(low <= high){
            int m = (low + high)/2;
            if(tmp > a[m])
                low = m + 1;
            else
                 high = m - 1;
        }
        for(int k = j; k > low; k--){
            a[k] = a[k - 1];
        }
        a[low] = tmp;
    }
2.希尔排序 Shell's sort又称缩小增量排序diminishing increment sort
属于插入排序类的方法，但在时间效率上较前几种排序方法有较大的改进，要有增量序列dlta[]
增量序列的值没有除1之外的公因子，且最后一个增量值必须为1

void ShellInsert(int (&a)[10], int dk){
//    cout << "the size id " << sizeof(a)/sizeof(a[0]);
    for(int i = dk + 1; i < 10; ++i){
        int j;
        for(j = i - dk; j >=0 ; j-=dk){
            if(a[i] >= a[j])
                break;
        }
        int tmp = a[i];
        for(int k = i; k > j ; k-=dk){
            a[k] = a[k - dk];
        }
        a[j + dk] =tmp;
    }
}

void ShellSort(int (&a)[10], int dlta[], int t){
    for(int i = 0; i < t; ++i){
        ShellInsert(a,dlta[i]);
    }
}
3.快速排序 最简单的一种就是人们熟知的气泡排序Bubble Sort
依次比较相邻两个记录关键字的大小，逆序时交换相邻记录，就可以将关键字最大的纪录
快排是对起泡排序的一种改进。基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
要记得递归哦

int Partition(int (&a)[10], int low, int high){
    int pivotkey = a[low];
    while(low < high){
        while(low < high && pivotkey < a[high]){
            --high;            
        }
        swap(a[low], a[high]);
        while(low < high && pivotkey > a[low]){
            ++low;
        }
        swap(a[low], a[high]);
    }
    return low;
    
}


void QSort(int (&a)[10], int low, int high){
    if(low < high){
        int pivotkey = Partition(a, low, high);
        QSort(a, low, pivotkey - 1);
        QSort(a, pivotkey + 1, high);
    }
    
}
4.选择排序
基本思想是：每一躺在n-i+1个记录中选取关键字最小的记录作为有序序列中的第i个记录。其中最简单的且为读者熟悉的是简单选择排序。Simple Selection Sort
5.堆排序 Heap sort
只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间。














































